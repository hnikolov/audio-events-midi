
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Audio Events MIDI 2026</title>
    <style>
        /* ===== ROOT COLOR VARIABLES ===== */
        :root {
            --color-primary: #1a73e8;
            --color-primary-light: #e7f3ff;
            --color-primary-dark: #0d47a1;
            --color-accent: #fbc02d;
            --color-danger: #dc3545;
            --color-border: #ddd;
            --color-border-light: #eee;
            --color-bg-light: #f0f2f5;
            --color-bg-lighter: #f7f9fa;
            --color-bg-panel: #f1f3f4;
            --color-text-primary: #333;
            --color-text-secondary: #5f6368;
            --color-text-muted: #7a5a00;
            --color-highlight: #fff9c4;
            --color-warning-bg: #fff3cd;

            /* === Layout variables === */
            --mobile-tab-height: 56px;         /* default; will be 0 in landscape */
            --mobile-playerbar-height: 132px;  /* measured at runtime */
            --mobile-topbar-height: 0px;       /* measured at runtime */

            /* === Split ratio (left column) – tweakable === */
            --split-left: 35%;
        }

        /* ===== LAYOUT & GLOBAL ===== */
        body {
            font-family: -apple-system, system-ui, sans-serif;
            max-width: 850px;
            margin: 1rem auto;
            background: var(--color-bg-light);
            padding: 10px;
        }
        .grid {
            display: grid;
            grid-template-columns: minmax(240px, var(--split-left)) 1fr; /* Landscape default; portrait overrides to block */
            gap: 20px;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        audio { width: 100%; }

        /* ===== BUTTONS & FORM ELEMENTS ===== */
        .primary { background: var(--color-primary); color: white; border: none; }
        .danger { color: var(--color-danger); border-color: var(--color-danger); font-size: 0.8rem; }

        /* ===== PLAYLIST COMPONENT ===== */
        #playlist-ui { border: 1px solid var(--color-border); border-radius: 8px; margin-top: 10px; overflow: hidden; }
        .playlist-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--color-border-light); cursor: pointer; font-size: 0.9rem; }
        .playlist-item.active { background: var(--color-primary-light); border-left: 4px solid var(--color-primary); font-weight: bold; }
        .playlist-item .danger { margin-left: 10px; }

        /* Prevent Chrome Android "Tap to Search" from triggering on row taps */
        .playlist-item,
        .playlist-item * {
            -webkit-user-select: none; /* Safari/Chrome WebKit */
            user-select: none;         /* Standard */
            -webkit-touch-callout: none; /* Prevent long-press callout (mostly iOS) */
        }

        /* Optional: remove tap highlight flash on Android */
        .playlist-item {
            -webkit-tap-highlight-color: transparent;
        }

        /* ===== MIDI PANEL COMPONENT ===== */
        .midi-panel {
            background: var(--color-bg-lighter);
            border: 1px solid var(--color-border);
            border-radius: 10px;
            padding: 1px 1px;
            margin-bottom: 12px;
        }
        .btn-connect { width: 100%; background: transparent; border: none; }
        .midi-status {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--color-primary);
            background: transparent;
            border-radius: 6px;
            padding: 2px 8px;
            transition: background-color 200ms ease, color 200ms ease;
        }
        /* Flash style (activity indicator) */
        .midi-status.cc-flash { background: var(--color-warning-bg) !important; color: var(--color-text-muted) !important; }

        /* ===== DIALOG & FORMS ===== */
        dialog { border: 1px solid var(--color-border); border-radius: 10px; padding: 12px; }
        dialog h3 { margin: 0 0 .5rem; }
        dialog .row { display: flex; align-items: center; gap: 8px; }
        dialog .form-spacing { margin-top: 0.75rem; }
        dialog label { display: flex; flex-direction: column; font-size: 0.9rem; }
        dialog select { width: 100%; padding: 6px; font-size: 1rem; }

        /* ===== PLAYBACK CONTROLS COMPONENT ===== */
        .controls-container {
            background: var(--color-bg-panel);
            padding: 5px 0px;
            border-radius: 0px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--color-border);
            flex-wrap: nowrap; /* force one line */
        }

        .control-btn {
            background: var(--color-bg-panel);
            color: black;
            border: none;
            width: 30px; height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
            font-size: 18px;
            padding: 0;
        }
        .control-btn:hover { background: #E5E7E8; }
        .control-btn.loop-active { background: #E5E7E8; box-shadow: 0 0 4px rgba(26, 115, 232, 0.4); }

        /* ===== SPEED MENU COMPONENT ===== */
        .speed-wrapper { position: relative; }
        .speed-btn-label { min-width: 50px; display: inline-flex; align-items: center; justify-content: center; font-size: 0.85rem; color: var(--color-text-secondary); font-weight: 500; }
        .speed-menu { position: absolute; background: white; border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,0.18); padding: 8px; display: none; z-index: 2000; min-width: 60px; }
        .speed-option { display: flex; align-items: center; justify-content: space-between; gap: 12px; font-size: 0.85rem; color: var(--color-text-secondary); font-weight: 500; padding: 12px 14px; border-radius: 8px; border: none; background: #ffffff; width: 100%; cursor: pointer; }
        .speed-option:hover { background: #f5f7f9; }
        .speed-option.active { font-weight: 600; color: var(--color-primary); background: #eef4ff; }

        /* ===== VOLUME SLIDER COMPONENT ===== */
        .volume-control { position: relative; display: inline-block; }
        .volume-control #vol-slider {
            position: absolute;
            bottom: 100%;
            display: none;
            padding: 8px;
            z-index: 1000;
        }
        .volume-control.expanded #vol-slider { display: block; }
        #vol-slider {
            appearance: slider-vertical;
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            width: 4px;
            height: 200px;
            background: transparent;
            cursor: pointer;
        }

        /* ===== MARKERS LIST COMPONENT ===== */
        .header-row { display: flex; justify-content: space-between; align-items: center; }
        .header-row h3 { margin: 0; }
        .markers-header { display: flex; justify-content: space-between; align-items: center; padding:0 10px}
        .markers-header h4 { margin: 0; }
        ul { list-style: none; padding: 0; margin-top: 10px; }
        li { display: flex; gap: 8px; align-items: center; padding: 8px; border-bottom: 1px solid var(--color-border-light); transition: background 0.3s; }
        li.active-event { background: var(--color-highlight); border-left: 4px solid var(--color-accent); }
        .marker-left   { flex: 1; }
        .marker-middle { flex: 1; text-align: center; }
        .marker-right  { flex: 1; display: flex; align-items: center; justify-content: flex-end; gap: 8px; }
        .preset-badge { font-size: 0.85rem; font-weight: 700; color: var(--color-text-primary); background: inherit; border: none; border-radius: 6px; padding: 2px 8px; }

        /* Keep the edit row on a single line and make it fit */
        #event-list li {
            display: flex;        /* already set in your CSS; harmless to repeat */
            align-items: center;
            gap: 8px;
        }

        #event-list .time-input,
        #event-list .preset-input {
            /* Critical bits: let inputs shrink below min-content width */
            flex: 1 1 0;          /* share remaining width, allow shrink */
            min-width: 0;         /* allow shrinking in flex context */
            width: 0;             /* WebKit/iOS: actually enable shrink */
            box-sizing: border-box;
        }

        #event-list li button {
            flex: 0 0 auto;       /* buttons keep natural width */
            white-space: nowrap;  /* avoid multi-line button labels */
        }

        /* ===== PROGRESS BAR COMPONENT ===== */
        .progress-container {
            background: var(--color-bg-panel);
            border: 1px solid var(--color-border);
            padding: 5px 10px;
            border-radius: 0px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0 5px;
            user-select: none;
        }
        .progress-track {
            position: relative;
            height: 10px;
            background: #B5B7B8;
            border-radius: 6px;
            flex: 1;
            cursor: pointer;
            overflow: hidden;
            touch-action: pan-y; /* allow vertical page scroll while supporting horizontal scrubs */
        }
        .progress-fill { position: absolute; left: 0; top: 0; height: 100%; width: 0%; background: var(--color-primary); z-index: 1; }

        /* Ghost preview (lookahead) */
        .progress-ghost-fill { position: absolute; left: 0; top: 0; height: 100%; width: 0%; background: var(--color-primary); opacity: 0.35; pointer-events: none; display: none; z-index: 1; }
        .progress-ghost { position: absolute; top: 0; width: 2px; height: 100%; background: var(--color-primary); opacity: 0.9; box-shadow: 0 0 6px rgba(0,0,0,0.35); pointer-events: none; transform: translateX(-1px); display: none; z-index: 4; }

        /* A/B loop region overlay */
        .progress-ab {
            position: absolute; top: 0; height: 100%; left: 0%; width: 0%;
            background: rgba(251, 192, 45, 0.25); display: none; z-index: 2;
        }
        .progress-ab.enabled { background: rgba(251, 192, 45, 0.6); }

        /* A/B loop handles */
        .ab-handle {
            position: absolute; top: 50%; width: 14px; height: 14px; border-radius: 50%;
            background: var(--color-accent); border: 2px solid #9c6f00; box-shadow: 0 1px 2px rgba(0,0,0,0.25);
            transform: translate(-50%, -50%); cursor: ew-resize;
        }
        .ab-handle.right { right: 0; left: auto; transform: translate(50%, -50%); }
        .ab-drag { position: absolute; left: 0; right: 0; top: 0; bottom: 0; cursor: grab; }
        .ab-drag.dragging { cursor: grabbing; }
        /* A/B drag targets: prevent the browser from treating drags as page scroll/zoom */
        .ab-handle,
        .ab-drag { touch-action: none; }

        .time-label { font-size: 0.85rem; color: var(--color-text-secondary); flex-shrink: 0; min-width: 74px; text-align: right; }

        /* Marker tick indicators on progress bar */
        .progress-tick {
            position: absolute; top: 0; width: 2px; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 3; pointer-events: none; transform: translateX(-1px);
        }
        .progress-tick.fired { background: var(--color-primary); opacity: 0.95; }
        .progress-tick.current { background: var(--color-accent); box-shadow: 0 0 6px rgba(251, 192, 45, 0.7); }

        /* ===== A/B LOOP CONTROLS COMPONENT ===== */
        #ab-controls { flex-wrap: wrap; row-gap: 10px; }
        #ab-controls .ab-btn { white-space: nowrap; flex: 0 0 auto; min-width: fit-content; }
        .ab-btn { border-radius: 16px; font-size: 18px; padding: 6px 12px; line-height: 1.2; width: auto; height: auto; }

        /* ===== TAB BAR (hidden by default; visible in portrait) ===== */
        .tab-bar { display: none; }
        .tab-bar .tab {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            color: #5f6368;
            cursor: pointer;
            user-select: none;
            min-height: 44px;
            touch-action: manipulation;
            font-size: clamp(1.05rem, 3vw, 1.25rem);
        }

        /* ===== FIXED BARS (global: both orientations & desktop) ===== */
        .mobile-midi-bar {
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 1000;
            background: #ffffff;
            border-bottom: 1px solid var(--color-border);
            padding-top: env(safe-area-inset-top);
        }
        .mobile-midi-bar .midi-panel {
            background: transparent;
            border: none;
            padding: 6px 10px;
            margin: 0;
        }

        .mobile-player-bar {
            position: fixed;
            left: 0; right: 0;
            background: var(--color-bg-panel);
            border-top: 1px solid var(--color-border);
            padding: 0px 0px;
            display: grid;             /* stack: progress over controls */
            grid-template-columns: 1fr;
            gap: 0px;
            z-index: 998;              /* tabs are 999 (portrait) */
            box-shadow: 0 -4px 12px rgba(0,0,0,0.08);
        }
        /* Use drop-up for menus inside the fixed bottom bar */
        .mobile-player-bar .speed-wrapper .speed-menu {
            top: auto;
            bottom: calc(100% + 6px);
        }
        /* Remove extra margins inside the bar */
        .mobile-player-bar .progress-container,
        .mobile-player-bar .controls-container { margin: 0; }

        /* ===== ORIENTATION: PORTRAIT ===== */
        @media (orientation: portrait) {
            /* Show tab bar in portrait */
            .tab-bar {
                position: fixed;
                bottom: 0; left: 0; right: 0;
                height: var(--mobile-tab-height);
                display: flex;
                background: #ffffff;
                border-top: 1px solid #ddd;
                z-index: 999;
                padding-bottom: env(safe-area-inset-bottom);
            }

            /* Single-pane with tabs */
            .grid { display: block; }
            .card { border-radius: 0; margin: 0; box-shadow: none; }
            .card.card-player h2 { margin-top: 0; }

            .card-playlist, .card-player { display: none; }
            #tab-playlist:checked ~ .mobile-tabs-container .card-playlist { display: block; }
            #tab-player:checked   ~ .mobile-tabs-container .card-player   { display: block; }

            /* Keep mini-player above the tab bar */
            .mobile-player-bar {
                bottom: calc(var(--mobile-tab-height) + env(safe-area-inset-bottom));
            }

            /* Container paddings so content doesn't go under fixed bars */
            .mobile-tabs-container {
                padding-top: var(--mobile-topbar-height);
                padding-bottom: calc(
                    var(--mobile-playerbar-height)
                    + var(--mobile-tab-height)
                    + env(safe-area-inset-bottom)
                );
            }

            /* Tab selected style */
            #tab-playlist:checked ~ .tab-bar label[for="tab-playlist"],
            #tab-player:checked   ~ .tab-bar label[for="tab-player"] {
                color: #1a73e8; font-weight: 600;
            }
        }

        /* ===== ORIENTATION: LANDSCAPE ===== */
        @media (orientation: landscape) {
            /* Hide tab bar */
            .tab-bar { display: none; }

            /* Two-pane layout */
            .grid {
                display: grid;
                grid-template-columns: minmax(240px, var(--split-left)) 1fr; /* 35% / 65% by default */
                gap: 20px;
            }
            .card-playlist, .card-player { display: block; }

            /* Mini-player sits at the bottom edge */
            .mobile-player-bar { bottom: env(safe-area-inset-bottom); }

            /* Container paddings (no tab bar here) */
            .mobile-tabs-container {
                padding-top: var(--mobile-topbar-height);
                padding-bottom: calc(
                    var(--mobile-playerbar-height)
                    + env(safe-area-inset-bottom)
                );
            }
        }

        /* ===== Touch-friendly adjustments (keep, independent of layout) ===== */
        @media (pointer: coarse) and (orientation: portrait) {
            .tab-bar .tab { font-size: 1.15rem; }
            h3, h4 { font-size: 1.2rem; }
            .playlist-item { font-size: 1rem; }
        }
        @media (pointer: coarse), (hover: none) {
            .ab-handle { width: 18px; height: 18px; }
            button:not(.control-btn) { font-size: 1rem; padding: 10px 14px; min-height: 44px; border-radius: 12px; }
            .primary { font-weight: 600; }
            .btn-connect { min-height: 44px; }
            html { font-size: 18px; -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
            body { max-width: none; margin: 0; padding: 0; background: #f0f2f5; }

            /* Larger thumb/track for vertical volume slider */
            #vol-slider { height: 88px; }
            #vol-slider::-webkit-slider-runnable-track { height: 6px; }
            #vol-slider::-webkit-slider-thumb { height: 18px; width: 18px; margin-top: -6px; }
            #vol-slider::-moz-range-track { height: 6px; }
            #vol-slider::-moz-range-thumb { height: 18px; width: 18px; border: none; }

            /* Progress bar height bump */
            .progress-track { height: 14px; }

            /* Touch-friendly control sizes */
            .control-btn { width: 44px; height: 44px; font-size: 20px; }
            .controls-container { flex-wrap: wrap; gap: 10px; }
        }

        /* === Sticky headers UNDER Connect (applies in PORTRAIT & LANDSCAPE) === */
        .card-playlist .header-row,
        .card-player #current-title {
            position: sticky;
            top: var(--mobile-topbar-height, 48px); /* uses measured height; 48px fallback */
            z-index: 10;
            background: #fff;       /* so content scrolls underneath cleanly */
        }

        .card-player #current-title {
            margin: 0;              /* remove default h2 margin that can look offset */
            display: block;         /* ensure background spans full width */
        }

        /* Make edit inputs match the visual size in the list, especially on phones */
        #event-list li.editing .time-input,
        #event-list li.editing .preset-input {
            /* Let inputs fill their column */
            width: 100%;
            box-sizing: border-box;

            /* Comfortable, consistent size on mobile */
            font-size: 1rem;        /* >=16px on your mobile base so no zoom */
            line-height: 1.2;
            padding: 10px 12px;
            min-height: 44px;       /* touch target size */
            border-radius: 8px;
        }
    </style>
</head>
<body>

<!-- Mobile tab state (CSS-only) -->
<input type="radio" name="mobile-tab" id="tab-playlist" checked hidden>
<input type="radio" name="mobile-tab" id="tab-player" hidden>

<!-- Fixed Top MIDI Bar (visible in both orientations) -->
<div id="mobileMidiBar" class="mobile-midi-bar" role="region" aria-label="MIDI connection">
  <div class="midi-panel">
    <button id="btnConnect" class="midi-status btn-connect" aria-label="Connect to MIDI device">
      Connect
    </button>
  </div>
</div>

<!-- USB dialog remains at body level -->
<dialog id="usbDialog">
  <form method="dialog">
    <h3>Select USB MIDI Output</h3>
    <div class="row">
      <label class="stretch">
        Output
        <select id="usbOutput" class="stretch"></select>
      </label>
    </div>
    <div class="row form-spacing">
      <button id="usbConnectBtn" type="button" class="primary">Connect</button>
      <span class="stretch"></span>
      <button id="usbCancelBtn" type="button">Cancel</button>
    </div>
  </form>
</dialog>

<div class="mobile-tabs-container">
    <div class="grid">

        <!-- PLAYLIST CARD -->
        <div class="card card-playlist">
            <div class="header-row">
                <h3>Playlist</h3>
                <input type="file" id="fileInput" accept="audio/*" multiple style="display:none">
                <label for="fileInput" class="primary" style="display:inline-block; padding:10px 14px; border-radius:4px; cursor:pointer; margin:0;">Add Audio</label>
            </div>

            <div id="playlist-ui"></div>
        </div>

        <!-- PLAYER CARD -->
        <div class="card card-player">
            <h2 id="current-title" style="padding:0px 10px">Select a song</h2>
            <audio id="audioTrack"></audio>

            <div class="markers-header">
                <h4>Markers</h4>
                <button class="primary" onclick="setEvent()">Add Marker</button>
            </div>

            <ul id="event-list"></ul>
        </div>
    </div>

    <!-- Fixed Mini-player (bottom) -->
    <div id="mobilePlayerBar" class="mobile-player-bar" role="region" aria-label="Mini player">

        <!-- Progress bar -->
        <div class="progress-container">
            <div id="progress-bar" class="progress-track">
                <div id="progress-fill" class="progress-fill"></div>
                <div id="progress-ghost-fill" class="progress-ghost-fill"></div>
                <div id="progress-ghost" class="progress-ghost"></div>             
                <div id="progress-ab" class="progress-ab">
                    <div id="ab-drag" class="ab-drag" data-role="segment"></div>
                    <div id="ab-handle-a" class="ab-handle left" data-role="handle-a"></div>
                    <div id="ab-handle-b" class="ab-handle right" data-role="handle-b"></div>
                </div>
            </div>
            <span id="time-label" class="time-label">0:00.0 / 0:00</span>
        </div>
        <!-- A/B loop controls -->
        <div class="controls-container" id="ab-controls" role="group" aria-label="A/B loop controls">
            <button id="abEnableBtn" class="control-btn ab-btn" onclick="toggleABLoop()" aria-label="Toggle A/B loop">AB</button>
            <button id="btnSetA" class="control-btn ab-btn" onclick="setLoopA()" aria-label="Set loop start point A">—</button>
            <button id="abVisibleBtn" class="control-btn" onclick="toggleABVisibility()" aria-label="Show or hide A/B loop on progress bar">⇄</button>
            <button id="btnSetB" class="control-btn ab-btn" onclick="setLoopB()" aria-label="Set loop end point B">—</button>
            <button class="control-btn ab-btn" onclick="rewindToA()" aria-label="Rewind to point A">↩</button>
        </div>
      
        <!-- Playback controls -->
        <div class="controls-container" role="group" aria-label="Playback controls">
            <button class="control-btn" onclick="stopAudio()" aria-label="Stop">■</button>
            <button class="control-btn" onclick="seekRelative(-10)" aria-label="Rewind 10 seconds">↺</button>
            <button id="playPauseBtn" class="control-btn" onclick="togglePlayPause()" aria-label="Play or pause">▶</button>
            <button class="control-btn" onclick="seekRelative(10)" aria-label="Fast forward 10 seconds">↻</button>
            <button id="loopBtn" class="control-btn" onclick="toggleLoop()" aria-label="Toggle loop">⇄</button>

            <div class="speed-wrapper">
                <button id="speedBtn" class="control-btn speed-btn-label" onclick="toggleSpeedMenu()" aria-label="Playback speed">1.00</button>
                <div id="speedMenu" class="speed-menu" role="menu"></div>
            </div>

            <!-- Volume control (drop-up) -->
            <div class="volume-control" id="volumeControl">
                <button id="volBtn" class="control-btn speed-btn-label" aria-label="Volume">100%</button>
                <input type="range" id="vol-slider" min="0" max="1" step="0.01" value="1" aria-label="Volume (vertical slider)">
            </div>
        </div>
    </div>
</div>

<script>
/* ============================ Robust IndexedDB ============================ */
const IDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;
let db = null;
const DB_NAME = "AudioMasterDB_2026";
const DB_VERSION = 1;
const STORE_SONGS = "songs";

function openDB() {
    return new Promise((resolve) => {
        if (!IDB) { console.warn("IndexedDB not available."); return resolve(null); }
        const req = IDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = (e) => {
            const _db = e.target.result;
            if (!_db.objectStoreNames.contains(STORE_SONGS)) {
                _db.createObjectStore(STORE_SONGS, { keyPath: "name" });
            }
        };
        req.onsuccess = (e) => resolve(e.target.result);
        req.onerror  = () => resolve(null);
    });
}
function getAllSongs() {
    return new Promise((resolve) => {
        if (!db) return resolve([]);
        const tx = db.transaction(STORE_SONGS, "readonly");
        const store = tx.objectStore(STORE_SONGS);
        const items = [];
        if ("getAll" in store) {
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror   = () => resolve([]);
        } else {
            const req = store.openCursor();
            req.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) { items.push(cursor.value); cursor.continue(); }
                else resolve(items);
            };
            req.onerror = () => resolve([]);
        }
    });
}
function putSongs(files) {
    return new Promise((resolve) => {
        if (!db) return resolve(false);
        const tx = db.transaction(STORE_SONGS, "readwrite");
        const store = tx.objectStore(STORE_SONGS);
        try {
            files.forEach((file) => {
                const blob = new Blob([file], { type: file.type || "audio/*" });
                store.put({ name: file.name, type: file.type || "", lastModified: file.lastModified || Date.now(), data: blob });
            });
        } catch (err) { console.error("IDB put error", err); }
        tx.oncomplete = () => resolve(true);
        tx.onerror    = () => resolve(false);
        tx.onabort    = () => resolve(false);
    });
}
function getSongByName(name) {
    return new Promise((resolve) => {
        if (!db) return resolve(null);
        const tx = db.transaction(STORE_SONGS, "readonly");
        const store = tx.objectStore(STORE_SONGS);
        const req = store.get(name);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror   = () => resolve(null);
    });
}
function removeSongFromDB(name) {
    return new Promise((resolve) => {
        if (!db) return resolve(false);
        const tx = db.transaction(STORE_SONGS, "readwrite");
        tx.objectStore(STORE_SONGS).delete(name);
        tx.oncomplete = () => resolve(true);
        tx.onerror    = () => resolve(false);
        tx.onabort    = () => resolve(false);
    });
}

/* ============================== App Constants ============================= */
const EPS_RECONCILE = 0.05;
const EPS_LOOP_B    = 0.02;
const CC_FLASH_MS   = 350;

const DEFAULT_DECIMALS = 1; // 1 => m:ss.S

/* =============================== DOM refs ================================ */
const audio = document.getElementById('audioTrack');
const volSlider = document.getElementById('vol-slider');
const loopBtn = document.getElementById('loopBtn');
const playlistUI = document.getElementById('playlist-ui');
const fileInput = document.getElementById('fileInput');

const playPauseBtn = document.getElementById('playPauseBtn');
const speedBtn = document.getElementById('speedBtn');
const speedMenu = document.getElementById('speedMenu');

const progressBar = document.getElementById('progress-bar');
const progressFill = document.getElementById('progress-fill');
const progressGhostFill = document.getElementById('progress-ghost-fill');
const progressGhost = document.getElementById('progress-ghost');
const progressAB = document.getElementById('progress-ab');
const abDrag = document.getElementById('ab-drag');
const abHandleA = document.getElementById('ab-handle-a');
const abHandleB = document.getElementById('ab-handle-b');
const timeLabel = document.getElementById('time-label');

const btnSetA = document.getElementById('btnSetA');
const btnSetB = document.getElementById('btnSetB');
const abEnableBtn = document.getElementById('abEnableBtn');
const abVisibleBtn = document.getElementById('abVisibleBtn');

const EVENT_MAP_KEY = 'audio_events_map_v1';
const VOLUME_MAP_KEY = 'audio_volume_map_v1';
const AB_LOOP_MAP_KEY = 'audio_ab_loop_map_v1';
const SPEED_MAP_KEY = 'audio_speed_map_v1';

/* ================================ State ================================= */
let currentFileName = "";
let activeBlobUrl = null;
let firedEvents = new Set();

// Extended A/B loop state with `visible`
let abLoop = { enabled: false, visible: true, a: null, b: null };

let lastTriggeredMarkerTime = null;
let lastTriggeredMarkerIndex = null;

let isScrubbing = false;
let wasPlaying = false;
let dragMode = null;
let pointerId = null;
let segmentWidthPct = 0;
let segmentLeftPct = 0;
let pointerOffsetPct = 0;

let scrubStartTime = null;
let scrubTargetTime = null;

const MIN_GAP_SEC = 0.05;
const AVAILABLE_SPEEDS = [0.6, 0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0];
// const ANCHOR_RATE = 2.0;

/* =============================== Helpers ================================ */
function configureGhostPreview({ fillColor, fillOpacity, lineColor, lineOpacity } = {}) {
    const root = document.documentElement;
    if (fillColor   !== undefined) root.style.setProperty('--ghost-fill-color', fillColor);
    if (fillOpacity !== undefined) root.style.setProperty('--ghost-fill-opacity', String(fillOpacity));
    if (lineColor   !== undefined) root.style.setProperty('--ghost-line-color', lineColor);
    if (lineOpacity !== undefined) root.style.setProperty('--ghost-line-opacity', String(lineOpacity));
}
configureGhostPreview({ fillColor: '#4aa3f8', fillOpacity: 0.5, lineColor: '#1a73e8', lineOpacity: 0.9 });

function safeRevoke(url) { if (url) { try { URL.revokeObjectURL(url); } catch {} } return null; }
function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

function formatClock(t, digits = DEFAULT_DECIMALS) {
    if (!isFinite(t) || t < 0) t = 0;
    const factor = Math.pow(10, digits);
    const units = Math.round(t * factor);
    const perMinute = 60 * factor;

    const m = Math.floor(units / perMinute);
    const sUnits = units % perMinute;
    const s = Math.floor(sUnits / factor);
    const frac = sUnits % factor;

    const secStr = String(s).padStart(2, '0');
    const fracStr = digits > 0 ? '.' + String(frac).padStart(digits, '0') : '';
    return `${m}:${secStr}${fracStr}`;
}

/* ================================ MIDI ================================== */
const btnConnect     = document.getElementById('btnConnect');
const statusEl       = document.getElementById('btnConnect');
const usbDialog      = document.getElementById('usbDialog');
const usbOutputEl    = document.getElementById('usbOutput');
const usbConnectBtn  = document.getElementById('usbConnectBtn');
const usbCancelBtn   = document.getElementById('usbCancelBtn');

const MIDI_SERVICE_UUID = '03b80e5a-ede8-4b33-a751-6ce34ec4c700';
const MIDI_CHARACTERISTIC_UUID = '7772e5db-3868-4112-a1a9-f2669d106bf3';

let currentTransport = null; // 'usb' | 'ble' | null
let device = null, server = null, service = null, midiChar = null; // BLE
let midiAccess = null, usbOutput = null; // USB Web MIDI

/* Single status setter: set the label's text (no connected background class) */
function setStatusText(text) { statusEl.textContent = text || ''; }

/* Flash visual (activity indicator on CC/PC sends) */
let ccFlashTimer = null;
function flashCcStatus() {
    statusEl.classList.remove('cc-flash');
    void statusEl.offsetWidth;
    statusEl.classList.add('cc-flash');
    if (ccFlashTimer) clearTimeout(ccFlashTimer);
    ccFlashTimer = setTimeout(() => {
        statusEl.classList.remove('cc-flash');
        ccFlashTimer = null;
    }, CC_FLASH_MS);
}

// --- BLE-MIDI Packet Helpers ---
function buildBleMidiPacket(midiBytes, useZeroTimestamp = false) {
    let tsHigh = 0x80, tsLow = 0x80;
    if (!useZeroTimestamp) {
        const ts = Math.floor(performance.now()) % 8192;
        tsHigh = 0x80 | (ts >> 7);
        tsLow  = 0x80 | (ts & 0x7F);
    }
    const packet = new Uint8Array(2 + midiBytes.length);
    packet[0] = tsHigh;
    packet[1] = tsLow;
    packet.set(midiBytes, 2);
    return packet;
}
async function writeBle(bytes, { forceResponse = false, useZeroTimestamp = false } = {}) {
    if (!midiChar) throw new Error('Not connected');
    const packet = buildBleMidiPacket(bytes, useZeroTimestamp);
    if (!forceResponse && typeof midiChar.writeValueWithoutResponse === 'function') {
        await midiChar.writeValueWithoutResponse(packet);
    } else {
        await midiChar.writeValue(packet);
    }
}
let bleQueue = Promise.resolve();
function enqueueBle(bytes, opts = {}) {
    bleQueue = bleQueue.then(() => writeBle(bytes, opts)).catch(() => { /* swallow transient errors */ });
    return bleQueue;
}

// USB Web MIDI helpers
async function ensureMidiAccess() {
    if (!navigator.requestMIDIAccess) return null;
    if (!midiAccess) {
        try { midiAccess = await navigator.requestMIDIAccess({ sysex: false }); }
        catch { midiAccess = null; }
    }
    return midiAccess;
}
function listUsbOutputs() {
    const outputs = [];
    if (!midiAccess) return outputs;
    for (const out of midiAccess.outputs.values()) outputs.push(out);
    return outputs;
}
function writeUsb(bytes) {
    if (!usbOutput) throw new Error('Not connected');
    usbOutput.send(bytes);
}

// Helper: connected device name (for routing CC vs PC)
function getConnectedDeviceName() {
    if (currentTransport === 'usb') {
        return (usbOutput && usbOutput.name) ? usbOutput.name : '';
    } else if (currentTransport === 'ble') {
        return (device && device.name) ? device.name : '';
    }
    return '';
}

// Map preset (1..100) → PC program (0..127)
function presetToProgram(preset) { let p = parseInt(preset,10); if (isNaN(p)) p=1; return Math.max(0, Math.min(127, p-1)); }

// --- Public APIs (flash on both CC and PC) ---
async function sendCc(channel, ccNumber, ccValue) {
    const ch  = Math.min(16, Math.max(1, Number(channel)  || 1));
    const cc  = Math.min(127, Math.max(0, Number(ccNumber) || 0));
    const val = Math.min(127, Math.max(0, Number(ccValue)  || 0));
    const status = 0xB0 + (ch - 1);
    const midiBytes = new Uint8Array([status, cc, val]);

    try {
        if (currentTransport === 'usb') {
            writeUsb(midiBytes);
            flashCcStatus();
        } else if (currentTransport === 'ble') {
            enqueueBle(midiBytes, { forceResponse: false, useZeroTimestamp: false })
                .then(() => { flashCcStatus(); });
        }
    } catch { /* swallow transient errors */ }
}
window.sendCc = sendCc;

async function sendPc(channel, program) {
    const ch  = Math.min(16, Math.max(1, Number(channel)  || 1));
    const pg  = Math.min(127, Math.max(0, Number(program) || 0));
    const status = 0xC0 + (ch - 1);
    const midiBytes = new Uint8Array([status, pg]);

    try {
        if (currentTransport === 'usb') {
            writeUsb(midiBytes);
            flashCcStatus();
        } else if (currentTransport === 'ble') {
            enqueueBle(midiBytes, { forceResponse: false, useZeroTimestamp: true })
                .then(() => { flashCcStatus(); });
        }
    } catch { /* swallow transient errors */ }
}
window.sendPc = sendPc;

let toDisconnect = 'x';
let toConnect = 'C';
let connectionStatus = toConnect;

async function connectOrDisconnect() {
    if (connectionStatus === toDisconnect) {
        if (currentTransport === 'ble') {
            try { if (device && device.gatt.connected) device.gatt.disconnect(); } catch {}
            device = server = service = midiChar = null;
        } else if (currentTransport === 'usb') {
            usbOutput = null;
        }
        currentTransport = null;
        connectionStatus = toConnect;
        setStatusText('Connect');
        return;
    }

    const access = await ensureMidiAccess();
    if (access) {
        const outputs = listUsbOutputs();

        if (outputs.length === 1) {
            const candidate = outputs[0];
            const ok = confirm(`Connect to USB MIDI output:\n\n${candidate.name || 'USB Output'}\n\nOK to connect, Cancel to choose BLE.`);
            if (ok) {
                usbOutput = candidate;
                currentTransport = 'usb';
                connectionStatus = toDisconnect;
                setStatusText(usbOutput.name || 'USB Output');
                return;
            }
        } else if (outputs.length > 1) {
            usbOutputEl.innerHTML = '';
            outputs.forEach(out => {
                const opt = document.createElement('option');
                opt.value = out.id;
                opt.textContent = out.name || `Output ${out.id}`;
                usbOutputEl.appendChild(opt);
            });
            usbDialog.showModal();

            const onConnect = () => {
                const id = usbOutputEl.value;
                usbOutput = access.outputs.get(id);
                usbDialog.close();
                usbConnectBtn.removeEventListener('click', onConnect);
                usbCancelBtn.removeEventListener('click', onCancel);
                if (usbOutput) {
                    currentTransport = 'usb';
                    connectionStatus.textContent = toDisconnect;
                    setStatusText(usbOutput.name || 'USB Output');
                } else {
                    connectBleFlow();
                }
            };
            const onCancel = () => {
                usbDialog.close();
                usbConnectBtn.removeEventListener('click', onConnect);
                usbCancelBtn.removeEventListener('click', onCancel);
                connectBleFlow();
            };
            usbConnectBtn.addEventListener('click', onConnect, { once: true });
            usbCancelBtn.addEventListener('click', onCancel,  { once: true });
            return;
        }
    }
    connectBleFlow();
}
async function connectBleFlow() {
    if (!navigator.bluetooth) { setStatusText('Web Bluetooth unavailable'); return; }
    try {
        setStatusText('Requesting BLE device...');
        device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [MIDI_SERVICE_UUID] }],
            optionalServices: [MIDI_SERVICE_UUID]
        });

        device.addEventListener('gattserverdisconnected', () => {
            connectionStatus = toConnect;
            setStatusText('Connect');
            device = server = service = midiChar = null;
            currentTransport = null;
        });

        setStatusText('Connecting…');
        server = await device.gatt.connect();
        service = await server.getPrimaryService(MIDI_SERVICE_UUID);
        midiChar = await service.getCharacteristic(MIDI_CHARACTERISTIC_UUID);

        // Some devices require notifications enabled to open data path
        try {
            await midiChar.startNotifications();
            midiChar.addEventListener('characteristicvaluechanged', () => { /* no-op */ });
        } catch { /* continue */ }

        currentTransport = 'ble';
        connectionStatus = toDisconnect;
        setStatusText(device.name || 'BLE Device');
    } catch {
        setStatusText('Error');
    }
}
btnConnect.addEventListener('click', connectOrDisconnect);

/* =============================== Controls ================================ */
function togglePlayPause() {
    if (!audio.src) return;
    if (audio.paused) { audio.play(); } else { audio.pause(); }
    updatePlayPauseUI();
}
function updatePlayPauseUI() { playPauseBtn.textContent = audio.paused ? '▶' : '⏸'; }
audio.addEventListener('play', updatePlayPauseUI);
audio.addEventListener('pause', updatePlayPauseUI);

function toggleSpeedMenu() {
    if (!audio.src) return;
    const isOpen = speedMenu.style.display === 'block';
    if (isOpen) speedMenu.style.display = 'none';
    // else { buildSpeedMenu(); speedMenu.style.display = 'block'; positionSpeedMenuToAnchor(ANCHOR_RATE); }
    else { buildSpeedMenu(); speedMenu.style.display = 'block'; }
}
function buildSpeedMenu() {
    speedMenu.querySelectorAll('.speed-option').forEach(el => el.remove());
    AVAILABLE_SPEEDS.forEach(rate => {
        const btn = document.createElement('button');
        btn.className = 'speed-option';
        btn.innerHTML = `${rate.toFixed(2)}`;
        if (audio.playbackRate === rate) btn.classList.add('active');
        btn.onclick = () => setPlaybackRate(rate);
        speedMenu.appendChild(btn);
    });
}
// function positionSpeedMenuToAnchor(anchorRate) {
//     const wrapper = speedBtn.closest('.speed-wrapper'); if (!wrapper) return;
//     const wRect = wrapper.getBoundingClientRect();
//     const bRect = speedBtn.getBoundingClientRect();
//     const mRect = speedMenu.getBoundingClientRect();
//     const options = Array.from(speedMenu.querySelectorAll('.speed-option'));
//     let anchorEl = options.find(el => parseFloat(el.textContent) === anchorRate) ||
//                    options.find(el => el.classList.contains('active')) ||
//                    options[Math.floor(options.length/2)];
//     if (!anchorEl) return;
//     const oRect = anchorEl.getBoundingClientRect();
//     const buttonCenterX = (bRect.left - wRect.left) + bRect.width / 2;
//     const buttonCenterY = (bRect.top  - wRect.top)  + bRect.height / 2;
//     const optionCenterY = (oRect.top  - mRect.top)  + oRect.height / 2;
//     const menuLeft = buttonCenterX - (mRect.width / 2);
//     const menuTop  = buttonCenterY - optionCenterY;
//     speedMenu.style.left = `${menuLeft}px`;
//     speedMenu.style.top  = `${menuTop}px`;
// }
function setPlaybackRate(rate) {
    audio.playbackRate = rate;
    speedBtn.innerHTML = `${rate.toFixed(2)}`;
    speedMenu.style.display = 'none';
    if (currentFileName) {
        const map = JSON.parse(localStorage.getItem(SPEED_MAP_KEY) || '{}');
        map[currentFileName] = rate;
        localStorage.setItem(SPEED_MAP_KEY, JSON.stringify(map));
    }
}
document.addEventListener('pointerdown', (e) => { if (!e.target.closest('.speed-wrapper')) speedMenu.style.display = 'none'; });

function seekRelative(seconds) {
    const prev = audio.currentTime;
    const dur = audio.duration || prev;
    const target = Math.min(Math.max(0, prev + seconds), dur);
    if (seconds < 0 && target < prev) { reconcileMarkersOnBackwardJump(target, prev); }
    else if (seconds > 0 && target > prev) { reconcileMarkersOnForwardJump(prev, target); }
    audio.currentTime = target;
}
function stopAudio() {
    audio.pause();
    audio.currentTime = 0;
    firedEvents.clear();
    lastTriggeredMarkerTime = null;
    lastTriggeredMarkerIndex = null;
    activeBlobUrl = safeRevoke(activeBlobUrl);
    document.querySelectorAll('#event-list li').forEach(el => el.classList.remove('active-event'));
    updateMarkerTicks();
    updatePlayPauseUI();
}
function toggleLoop() { audio.loop = !audio.loop; loopBtn.classList.toggle('loop-active', audio.loop); }

/* ============================ A/B Loop Controls ========================== */
function isABValid() { return abLoop.a !== null && abLoop.b !== null && abLoop.b > abLoop.a; }
function renderABButtons() {
    const aStr = (abLoop.a === null) ? '—' : formatClock(abLoop.a);
    const bStr = (abLoop.b === null) ? '—' : formatClock(abLoop.b);
    btnSetA.innerHTML = `${aStr}`;
    btnSetB.innerHTML = `${bStr}`;
    abVisibleBtn.classList.toggle('loop-active', !!abLoop.visible);
}
function updateABUI() {
    const valid = isABValid();
    abEnableBtn.classList.toggle('loop-active', abLoop.enabled && valid);
    renderABButtons();
}
function toggleABLoop() { abLoop.enabled = !abLoop.enabled; if (abLoop.enabled) abLoop.visible = true; saveABLoop(); }
function toggleABVisibility() { abLoop.visible = !abLoop.visible; saveABLoop(); }
// function toggleABVisibility() { 
    // abLoop.visible = !abLoop.visible;
    // if (abLoop.visible) { abLoop.enabled = true; }
    // else { abLoop.enabled = false; }
    // saveABLoop(); 
// }
function setLoopA() {
    abLoop.a = audio.currentTime;
    if (abLoop.b !== null && abLoop.b <= abLoop.a + MIN_GAP_SEC) {
        abLoop.b = Math.min(audio.duration || abLoop.a + MIN_GAP_SEC, abLoop.a + MIN_GAP_SEC);
    }
    abLoop.visible = true;
    if (abLoop.a < abLoop.b - MIN_GAP_SEC) { abLoop.enabled = true; }
    else { abLoop.enabled = false; }
    saveABLoop();
}
function setLoopB() {
    abLoop.b = audio.currentTime;
    if (abLoop.a !== null && abLoop.b <= abLoop.a + MIN_GAP_SEC) {
        abLoop.a = Math.max(0, abLoop.b - MIN_GAP_SEC);
    }
    abLoop.visible = true;
    if (abLoop.a < abLoop.b - MIN_GAP_SEC) { abLoop.enabled = true; }
    else { abLoop.enabled = false; }
    saveABLoop();
}
function rewindToA() {
    const a = (abLoop.a !== null) ? abLoop.a : 0;
    reconcileMarkersOnBackwardJump(a, audio.currentTime);
    audio.currentTime = Math.min(Math.max(0, a), audio.duration || a);
}
function loadABLoop() {
    const map = JSON.parse(localStorage.getItem(AB_LOOP_MAP_KEY) || '{}');
    const entry = map[currentFileName];
    abLoop = entry ? {
        enabled: !!entry.enabled,
        visible: entry.visible === undefined ? true : !!entry.visible,
        a: entry.a ?? null,
        b: entry.b ?? null
    } : { enabled: false, visible: true, a: null, b: null };
    updateABUI();
    updateABOverlay();
}
function saveABLoop() {
    if (!currentFileName) return;
    const map = JSON.parse(localStorage.getItem(AB_LOOP_MAP_KEY) || '{}');
    map[currentFileName] = abLoop;
    localStorage.setItem(AB_LOOP_MAP_KEY, JSON.stringify(map));
    updateABUI();
    updateABOverlay();
}

/* =========================== Progress / Overlay ========================== */
function renderTimeLabel(currentTime) {
    const dur = audio.duration || 0;
    timeLabel.textContent = `${formatClock(currentTime)} / ${formatClock(dur, 0)}`;
}
function updateProgressUI() {
    const dur = audio.duration || 0;
    const pct = dur ? (audio.currentTime / dur) * 100 : 0;
    progressFill.style.width = `${pct}%`;
    renderTimeLabel(audio.currentTime);
    updateABOverlay();
}
function updateABOverlay() {
    const dur = audio.duration;
    const show = abLoop.visible && isABValid() && dur && isFinite(dur);
    progressAB.style.display = show ? 'block' : 'none';
    if (!show) return;
    const aPct = (abLoop.a / dur) * 100;
    const bPct = (abLoop.b / dur) * 100;
    progressAB.style.left = `${aPct}%`;
    progressAB.style.width = `${Math.max(0, bPct - aPct)}%`;
    progressAB.classList.toggle('enabled', !!abLoop.enabled && !!abLoop.visible);
}
function xToTime(clientX) {
    const rect = progressBar.getBoundingClientRect();
    const ratio = (clientX - rect.left) / rect.width;
    const dur = audio.duration || 0;
    return Math.min(Math.max(0, ratio * dur), dur);
}
function showGhostPreview(targetTime) {
    const dur = audio.duration || 0;
    if (!dur || !isFinite(dur)) return;
    const pct = (targetTime / dur) * 100;
    progressGhostFill.style.width = `${pct}%`;
    progressGhostFill.style.display = 'block';
    progressGhost.style.left = `${pct}%`;
    progressGhost.style.display = 'block';
}
function hideGhostPreview() { progressGhostFill.style.display = 'none'; progressGhost.style.display = 'none'; }

/* ====================== Markers (with MIDI dispatch) ===================== */
function fireMarkerByIndex(i, evt, opts) {
    const forceSend = (opts && opts.forceCc) ? true : false;
    const firedBefore = firedEvents.has(evt.time);

    firedEvents.add(evt.time);
    lastTriggeredMarkerTime = evt.time;
    lastTriggeredMarkerIndex = i;

    setActiveMarkerUIByIndex(i);
    updateTickFiredClassByIndex(i, true);

    const name = getConnectedDeviceName();
    const isPocketMaster = (name || '').toLowerCase().includes('pocket master');

    if (currentTransport) {
        if (forceSend || !firedBefore) {
            try {
                if (isPocketMaster) window.sendCc(1, 1, evt.preset);
                else window.sendPc(1, presetToProgram(evt.preset));
            } catch {}
        }
    }
}

/* =========================== Pointer handlers ============================ */
function onPointerDown(e) {
    if (!audio.src) return;
    pointerId = e.pointerId;
    progressBar.setPointerCapture(pointerId);
    wasPlaying = !audio.paused;
    if (wasPlaying) audio.pause();

    const role = e.target.dataset.role || null;
    const dur = audio.duration || 0;
    const rect = progressBar.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;

    if (role === 'handle-a') {
        dragMode = 'handle-a';
    } else if (role === 'handle-b') {
        dragMode = 'handle-b';
    } else if (role === 'segment') {
        dragMode = 'segment';
        const aPct = (abLoop.a / dur);
        const bPct = (abLoop.b / dur);
        segmentLeftPct = aPct;
        segmentWidthPct = Math.max(0, bPct - aPct);
        pointerOffsetPct = clamp(ratio - segmentLeftPct, 0, segmentWidthPct);
        abDrag.classList.add('dragging');
    } else {
        dragMode = 'scrub';
        isScrubbing = true;
        scrubStartTime = audio.currentTime;
        scrubTargetTime = xToTime(e.clientX);
        showGhostPreview(scrubTargetTime);
        renderTimeLabel(scrubTargetTime);
    }
    e.preventDefault();
}
function onPointerMove(e) {
    if (!dragMode) return;
    const dur = audio.duration || 0;
    if (dur <= 0) return;

    if (dragMode === 'scrub') {
        scrubTargetTime = xToTime(e.clientX);
        showGhostPreview(scrubTargetTime);
        renderTimeLabel(scrubTargetTime);
        return;
    }
    const rect = progressBar.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;
    const time = clamp(ratio * dur, 0, dur);

    if (dragMode === 'handle-a') {
        const maxA = (abLoop.b !== null) ? (abLoop.b - MIN_GAP_SEC) : dur - MIN_GAP_SEC;
        abLoop.a = clamp(time, 0, Math.max(0, maxA));
        updateABOverlay(); updateABUI();
    } else if (dragMode === 'handle-b') {
        const minB = (abLoop.a !== null) ? (abLoop.a + MIN_GAP_SEC) : MIN_GAP_SEC;
        abLoop.b = clamp(time, minB, dur);
        updateABOverlay(); updateABUI();
    } else if (dragMode === 'segment') {
        const newLeftPct = clamp(ratio - pointerOffsetPct, 0, 1 - segmentWidthPct);
        abLoop.a = newLeftPct * dur;
        abLoop.b = (newLeftPct + segmentWidthPct) * dur;
        updateABOverlay(); updateABUI();
    }
}
function onPointerUp(e) {
    if (pointerId !== null) { try { progressBar.releasePointerCapture(pointerId); } catch {} }
    pointerId = null;

    if (dragMode === 'scrub') {
        const start = scrubStartTime ?? audio.currentTime;
        const target = clamp(scrubTargetTime ?? audio.currentTime, 0, audio.duration || audio.currentTime);
        hideGhostPreview();

        if (target < start) { reconcileMarkersOnBackwardJump(target, start); }
        else if (target > start) { reconcileMarkersOnForwardJump(start, target); }

        audio.currentTime = target;
        isScrubbing = false; scrubStartTime = null; scrubTargetTime = null;

        if (wasPlaying) audio.play();
        updatePlayPauseUI(); updateProgressUI();
    } else if (dragMode) {
        saveABLoop();
        abDrag.classList.remove('dragging');
    }
    dragMode = null;
}
function onPointerCancel(e) {
    hideGhostPreview();
    updateProgressUI();
    if (wasPlaying && audio.paused) { audio.play(); updatePlayPauseUI(); }
    dragMode = null; isScrubbing = false; scrubStartTime = null; scrubTargetTime = null; pointerId = null;
}
progressBar.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointermove', onPointerMove);
window.addEventListener('pointerup', onPointerUp);
window.addEventListener('pointercancel', onPointerCancel);

/* ========================== File Management (IDB) ======================== */
fileInput.addEventListener('click', () => { fileInput.value = ''; });
fileInput.onchange = async () => {
    const files = Array.from(fileInput.files || []);
    fileInput.value = '';
    if (!files.length || !db) return;

    await putSongs(files);
    await renderPlaylist();
};

async function renderPlaylist() {
    if (!db) {
        playlistUI.innerHTML = "<div style='padding:10px'>Storage unavailable</div>";
        return;
    }
    const songs = await getAllSongs();
    playlistUI.innerHTML = songs.length ? "" : "<div style='padding:10px'>Empty</div>";
    songs.forEach(song => {
        const row = document.createElement('div');
        row.className = `playlist-item ${song.name === currentFileName ? 'active' : ''}`;
        const label = document.createElement('span');
        label.textContent = song.name;

        const del = document.createElement('button');
        del.className = 'danger';
        del.textContent = '×';
        del.title = 'Remove';
        del.onclick = async (e) => {
            e.stopPropagation();
            if (confirm(`Remove ${song.name}?`)) {
                const ok = await removeSongFromDB(song.name);
                if (ok) {
                    if (currentFileName === song.name) {
                        audio.src = "";
                        currentFileName = "";
                        firedEvents.clear();
                        lastTriggeredMarkerTime = null;
                        lastTriggeredMarkerIndex = null;
                        activeBlobUrl = safeRevoke(activeBlobUrl);
                        updateMarkerTicks();
                    }
                    await renderPlaylist();
                }
            }
        };

        row.onclick = () => playSong(song.name);
        row.appendChild(label);
        row.appendChild(del);
        playlistUI.appendChild(row);
    });
}

async function playSong(name) {
    const song = await getSongByName(name);
    if (!song) return;

    currentFileName = name;
    document.getElementById('current-title').textContent = name;
    activeBlobUrl = safeRevoke(activeBlobUrl);
    activeBlobUrl = URL.createObjectURL(song.data);
    audio.src = activeBlobUrl;

    const volMap = JSON.parse(localStorage.getItem(VOLUME_MAP_KEY) || '{}');
    const savedVol = volMap[name] !== undefined ? volMap[name] : 1.0;
    audio.volume = savedVol;
    audio.muted = false;
    volSlider.value = savedVol;
    volBtn.textContent = `${Math.round(savedVol * 100)}%`;

    const speedMap = JSON.parse(localStorage.getItem(SPEED_MAP_KEY) || '{}');
    const savedRate = speedMap[name] !== undefined ? speedMap[name] : 1.0;
    audio.playbackRate = savedRate;
    speedBtn.innerHTML = `${savedRate.toFixed(2)}`;

    firedEvents.clear();
    lastTriggeredMarkerTime = null;
    lastTriggeredMarkerIndex = null;

    await refreshEventUI();
    loadABLoop();
    updateMarkerTicks();
    updatePlayPauseUI();
    updateMuteUI();
    audio.play();

    await renderPlaylist();
}

/* -------------------------------- VOLUME -------------------------------- */
const volumeControl = document.getElementById('volumeControl');
const volBtn = document.getElementById('volBtn');
let volumeHideTimer = null;

volSlider.oninput = (e) => {
    audio.volume = e.target.value;
    resetVolumeHideTimer();
};

audio.addEventListener('volumechange', () => {
    const vol = audio.volume;
    volSlider.value = vol;
    updateMuteUI();
    if (currentFileName) {
        const volMap = JSON.parse(localStorage.getItem(VOLUME_MAP_KEY) || '{}');
        volMap[currentFileName] = vol;
        localStorage.setItem(VOLUME_MAP_KEY, JSON.stringify(volMap));
    }
});

function updateMuteUI() {
    const vol = audio.volume;
    const volPct = Math.round(vol * 100);
    volBtn.textContent = vol === 0 ? 'Muted' : `${volPct}%`;
}
/* Volume control toggle and auto-hide */
function resetVolumeHideTimer() {
    if (volumeHideTimer) clearTimeout(volumeHideTimer);
    volumeControl.classList.add('expanded');
    volumeHideTimer = setTimeout(() => {
        volumeControl.classList.remove('expanded');
        volumeHideTimer = null;
    }, 1500);
}
volBtn.addEventListener('click', (e) => {
    if (!audio.src) return;
    e.stopPropagation();
    resetVolumeHideTimer();
    volSlider.focus();
});

/* Collapse volume control when clicking outside */
document.addEventListener('pointerdown', (e) => {
    if (!volumeControl.contains(e.target) && volumeControl.classList.contains('expanded')) {
        volumeControl.classList.remove('expanded');
        if (volumeHideTimer) clearTimeout(volumeHideTimer);
    }
});

/* Collapse when pressing Escape */
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && volumeControl.classList.contains('expanded')) {
        volumeControl.classList.remove('expanded');
        if (volumeHideTimer) clearTimeout(volumeHideTimer);
    }
});

/* -------------------------- Markers (with preset) ------------------------ */
function getEvents() {
    const map = JSON.parse(localStorage.getItem(EVENT_MAP_KEY) || '{}');
    const raw = map[currentFileName] || [];
    if (raw.length && typeof raw[0] === 'number') {
        const migrated = raw.map(t => ({ time: t, preset: 1 }));
        map[currentFileName] = migrated;
        localStorage.setItem(EVENT_MAP_KEY, JSON.stringify(map));
        return migrated;
    }
    return raw;
}
function saveEvents(list) {
    const map = JSON.parse(localStorage.getItem(EVENT_MAP_KEY) || '{}');
    map[currentFileName] = list.slice().sort((a,b) => a.time - b.time);
    localStorage.setItem(EVENT_MAP_KEY, JSON.stringify(map));
}
function formatPreset(preset) {
    let n = parseInt(preset, 10);
    if (isNaN(n)) n = 1;
    n = Math.min(100, Math.max(1, n));
    if (n <= 50) { return `P${String(n).padStart(2, '0')}`; }
    return `F${String(n - 50).padStart(2, '0')}`;
}
async function refreshEventUI() {
    const events = getEvents();
    const list = document.getElementById('event-list');
    list.innerHTML = events.length ? "" : "<li>No markers.</li>";
    events.forEach((evt, i) => {
        const li = document.createElement('li');
        li.id = `row-${i}`;
        li.innerHTML = `
            <span class="marker-left"><b>${formatClock(evt.time)}</b></span>
            <span class="marker-middle"><span class="preset-badge">${formatPreset(evt.preset)}</span></span>
            <span class="marker-right">
                <button onclick="toggleEdit(${i})">Edit</button>
                <button class="danger" onclick="deleteEvent(${i})">×</button>
            </span>`;
        list.appendChild(li);
    });
    updateMarkerTicks();
}
function toggleEdit(idx) {
  const evt = getEvents()[idx];
  const li = document.getElementById(`row-${idx}`);
  li.classList.add('editing');
  li.innerHTML = `
    <span class="marker-left">
      <input type="number" step="0.1" class="time-input" id="edit-time-${idx}" value="${evt.time}">
    </span>
    <span class="marker-middle" style="text-align:center">
      <input type="number" min="1" max="100" step="1" class="preset-input" id="edit-preset-${idx}" value="${evt.preset}">
    </span>
    <span class="marker-right">
      <button onclick="saveEdit(${idx})">Save</button>
      <button onclick="refreshEventUI()">Cancel</button>
    </span>`;
}

function saveEdit(idx) {
    const events = getEvents();
    const old = events[idx];
    const newTime = parseFloat(document.getElementById(`edit-time-${idx}`).value);
    let newPreset = parseInt(document.getElementById(`edit-preset-${idx}`).value, 10);
    if (isNaN(newTime)) return;
    if (isNaN(newPreset)) newPreset = 1;
    newPreset = Math.min(100, Math.max(1, newPreset));

    const updated = events.slice();
    updated[idx] = { time: newTime, preset: newPreset };
    saveEvents(updated);

    firedEvents.delete(old.time);
    if (lastTriggeredMarkerIndex === idx || lastTriggeredMarkerTime === old.time) {
        lastTriggeredMarkerIndex = null;
        lastTriggeredMarkerTime = null;
    }
    refreshEventUI();
    updateMarkerTicks();
}
function setEvent() {
    if (!currentFileName) return;
    const events = getEvents();
    const now = parseFloat(audio.currentTime.toFixed(1)); // align with deciseconds display
    if (!events.some(e => e.time === now)) {
        saveEvents([...events, { time: now, preset: 1 }]);
        refreshEventUI();
        updateMarkerTicks();
    }
}
function deleteEvent(idx) {
    const events = getEvents();
    const t = (events[idx] && events[idx].time) ?? null;
    const updated = events.filter((_, i) => i !== idx);
    saveEvents(updated);
    if (t !== null) {
        firedEvents.delete(t);
        if (lastTriggeredMarkerIndex === idx || lastTriggeredMarkerTime === t) {
            lastTriggeredMarkerIndex = null;
            lastTriggeredMarkerTime = null;
        }
    }
    refreshEventUI();
    updateMarkerTicks();
}
function updateMarkerTicks() {
    progressBar.querySelectorAll('.progress-tick').forEach(el => el.remove());
    const dur = audio.duration;
    const events = getEvents();
    if (!dur || !isFinite(dur) || !events.length) return;

    events.forEach((evt, i) => {
        const pct = (evt.time / dur) * 100;
        const tick = document.createElement('div');
        tick.className = 'progress-tick';
        tick.id = `tick-${i}`;
        tick.style.left = `${pct}%`;
        tick.title = `${formatClock(evt.time)} • ${formatPreset(evt.preset)}`;
        if (firedEvents.has(evt.time)) tick.classList.add('fired');
        if (lastTriggeredMarkerIndex === i) tick.classList.add('current');
        progressBar.appendChild(tick);
    });
}
function setActiveMarkerUIByIndex(i) {
    document.querySelectorAll('#event-list li').forEach(el => el.classList.remove('active-event'));
    const li = document.getElementById(`row-${i}`); if (li) li.classList.add('active-event');
    progressBar.querySelectorAll('.progress-tick').forEach(el => el.classList.remove('current'));
    const tick = document.getElementById(`tick-${i}`); if (tick) tick.classList.add('current');
}
function updateTickFiredClassByIndex(i, fired) {
    const tick = document.getElementById(`tick-${i}`);
    if (tick) tick.classList.toggle('fired', !!fired);
}
function nearestMarkerAtOrBefore(time, epsilon = EPS_RECONCILE) {
    const events = getEvents();
    if (!events.length) return null;
    const candidates = events.map((evt, i) => ({ ...evt, i })).filter(e => e.time <= time + epsilon);
    if (!candidates.length) return null;
    return candidates.reduce((best, e) =>
        Math.abs(e.time - time) < Math.abs(best.time - time) ? e : best
    );
}

/* =================== Reconciliation (scrub/rewind/forward) ================== */
function reconcileMarkersOnBackwardJump(targetTime, prevTime) {
    const events = getEvents();
    if (!events.length) return;

    events.forEach((evt, i) => {
        const t = evt.time;
        if (t > targetTime && t <= prevTime) {
            firedEvents.delete(t);
            updateTickFiredClassByIndex(i, false);
        }
    });

    const nearest = nearestMarkerAtOrBefore(targetTime, EPS_RECONCILE);
    if (nearest) {
        fireMarkerByIndex(nearest.i, nearest, { forceCc: true });
    } else {
        lastTriggeredMarkerTime = null;
        lastTriggeredMarkerIndex = null;
        progressBar.querySelectorAll('.progress-tick').forEach(el => el.classList.remove('current'));
        document.querySelectorAll('#event-list li').forEach(el => el.classList.remove('active-event'));
    }
}
function reconcileMarkersOnForwardJump(prevTime, targetTime) {
    const events = getEvents();
    if (!events.length) return;

    events.forEach((evt, i) => {
        const t = evt.time;
        if (t > prevTime && t <= targetTime) {
            firedEvents.add(t);
            updateTickFiredClassByIndex(i, true);
        }
    });

    const nearest = nearestMarkerAtOrBefore(targetTime, EPS_RECONCILE);
    if (nearest) {
        fireMarkerByIndex(nearest.i, nearest, { forceCc: true });
    } else {
        lastTriggeredMarkerTime = null;
        lastTriggeredMarkerIndex = null;
        progressBar.querySelectorAll('.progress-tick').forEach(el => el.classList.remove('current'));
        document.querySelectorAll('#event-list li').forEach(el => el.classList.remove('active-event'));
    }
}
function reconcileMarkersOnLoopRewind(loopStartA, loopEndB) {
    reconcileMarkersOnBackwardJump(loopStartA, loopEndB);
}

/* =================== Trigger logic + AB guard with visibility ============== */
audio.addEventListener('timeupdate', () => {
    const now = audio.currentTime;

    let fireNow = now;
    if (abLoop.enabled && abLoop.visible && isABValid()) {
        fireNow = Math.min(now, abLoop.b);
    }

    getEvents().forEach((evt, i) => {
        const t = evt.time;
        if (!firedEvents.has(t) && fireNow >= t) {
            fireMarkerByIndex(i, evt, { forceCc: false });
        }
        if (now < t - 0.5) { firedEvents.delete(t); updateTickFiredClassByIndex(i, false); }
        if (now === 0.0 && t === 0.0) { firedEvents.delete(t); updateTickFiredClassByIndex(i, false); }
    });

    updateProgressUI();

    if (abLoop.enabled && abLoop.visible && isABValid()) {
        if (now >= (abLoop.b - EPS_LOOP_B)) {
            reconcileMarkersOnLoopRewind(abLoop.a, abLoop.b);
            audio.currentTime = abLoop.a;
            if (audio.paused) audio.play();
            updatePlayPauseUI();
        }
    }
});

audio.addEventListener('loadedmetadata', () => {
    updateProgressUI();
    updateABOverlay();
    updateMarkerTicks();
    updatePlayPauseUI();
    updateMuteUI();

    const speedMap = JSON.parse(localStorage.getItem(SPEED_MAP_KEY) || '{}');
    const savedRate = currentFileName ? (speedMap[currentFileName] ?? audio.playbackRate) : audio.playbackRate;
    audio.playbackRate = savedRate;
    speedBtn.innerHTML = `${savedRate.toFixed(2)}`;

    renderABButtons();
});
audio.addEventListener('seeked', updateProgressUI);

/* ============================== Initialize DB ============================= */
(async function init() {
    db = await openDB();
    await renderPlaylist();
})();

/* ===================== Fixed bars: measure heights (no re-parenting) ===================== */
(function () {
  const root = document.documentElement;

  function setHeights() {
    const topBar    = document.getElementById('mobileMidiBar');
    const bottomBar = document.getElementById('mobilePlayerBar');
    if (topBar) {
      const th = topBar.offsetHeight || 0;
      root.style.setProperty('--mobile-topbar-height', th + 'px');
    }
    if (bottomBar) {
      const bh = bottomBar.offsetHeight || 0;
      root.style.setProperty('--mobile-playerbar-height', bh + 'px');
    }
  }

  let scheduled = false;
  function rafSetHeights() {
    if (scheduled) return;
    scheduled = true;
    requestAnimationFrame(() => { scheduled = false; setHeights(); });
  }

  window.addEventListener('resize', rafSetHeights, { passive: true });
  window.addEventListener('orientationchange', setHeights);
  document.addEventListener('DOMContentLoaded', () => {
    setHeights();
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(setHeights).catch(() => {});
    }
  });
})();
</script>

<!-- Bottom tab bar (visible only in portrait via CSS) -->
<nav class="tab-bar">
    <label for="tab-playlist" class="tab">Playlist</label>
    <label for="tab-player" class="tab">Player</label>
</nav>

</body>
</html>
